// Copyright 2017 Johan Brandhorst. All Rights Reserved.
// See LICENSE for licensing terms.

package main

import (
	"crypto/tls"
	"errors"
	"fmt"
	"html/template"
	"log"
	"math"
	"net/http"
	"os"
	"sort"
	"strings"
	"time"

	jwtmiddleware "github.com/auth0/go-jwt-middleware"
	jwt "github.com/dgrijalva/jwt-go"

	"github.com/anxiousmodernman/goth"
	"github.com/anxiousmodernman/goth/gothic"
	"github.com/anxiousmodernman/goth/providers/auth0"
	"github.com/gorilla/pat"
	"github.com/gorilla/sessions"
	"github.com/gorilla/websocket"
	"github.com/improbable-eng/grpc-web/go/grpcweb"
	"github.com/johanbrandhorst/protobuf/wsproxy"
	"github.com/sirupsen/logrus"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/grpclog"

	"gitlab.com/DSASanFrancisco/co-chair/backend"
	"gitlab.com/DSASanFrancisco/co-chair/frontend/bundle"
	"gitlab.com/DSASanFrancisco/co-chair/proto/server"
)

// TODO pass this down to my object
var logger *logrus.Logger

func init() {
	logger = logrus.StandardLogger()
	logrus.SetLevel(logrus.DebugLevel)
	logrus.SetFormatter(&logrus.TextFormatter{
		ForceColors:     true,
		FullTimestamp:   true,
		TimestampFormat: time.RFC3339Nano,
		DisableSorting:  true,
	})
	// Should only be done from init functions
	grpclog.SetLoggerV2(grpclog.NewLoggerV2(logger.Out, logger.Out, logger.Out))

	// GOTH INIT
	store := sessions.NewFilesystemStore(os.TempDir(), []byte("goth-example"))

	// set the maxLength of the cookies stored on the disk to a larger number to prevent issues with:
	// securecookie: the value is too long
	// when using OpenID Connect , since this can contain a large amount of extra information in the id_token

	// Note, when using the FilesystemStore only the session.ID is written to a browser cookie, so this is explicit for the storage on disk
	store.MaxLength(math.MaxInt64)

	gothic.Store = store
}

func main() {

	goth.UseProviders(
		auth0.New(
			os.Getenv("COCHAIR_AUTH0_CLIENTID"),
			os.Getenv("COCHAIR_AUTH0_SECRET"), "https://localhost:2016/auth/auth0/callback",
			os.Getenv("COCHAIR_AUTH0_DOMAIN")),
	)

	m := make(map[string]string)
	m["auth0"] = "Auth0"

	var ks []string
	for k := range m {
		ks = append(ks, k)
	}
	sort.Strings(ks)

	_ = &ProviderIndex{Providers: ks, ProvidersMap: m}

	// NewProxy gives us a Proxy, our concrete implementation of the
	// interface generated by the grpc protobuf compiler.
	px, err := backend.NewProxy("co-chair.db")
	if err != nil {
		log.Fatalf("proxy init: %v", err)
	}

	gs := grpc.NewServer()
	server.RegisterProxyServer(gs, px)
	wrappedServer := grpcweb.WrapServer(gs)

	clientCreds, err := credentials.NewClientTLSFromFile("./cert.pem", "")
	if err != nil {
		logger.WithError(err).Fatal("Failed to get local server client credentials, did you run `make generate_cert`?")
	}

	wsproxy := wsproxy.WrapServer(
		http.HandlerFunc(wrappedServer.ServeHTTP),
		wsproxy.WithLogger(logger),
		wsproxy.WithTransportCredentials(clientCreds))

	jwtMiddleware := jwtmiddleware.New(jwtmiddleware.Options{
		ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {
			return []byte(os.Getenv("COCHAIR_AUTH0_SECRET")), nil
		},
		ErrorHandler: func(w http.ResponseWriter, r *http.Request, msg string) {
			logger.Debug("middleware error:", msg)
			w.Header().Set("Location", "/login")
			w.WriteHeader(http.StatusTemporaryRedirect)
		},
		Extractor:     extractor,
		SigningMethod: jwt.SigningMethodHS256,
	})

	protect := func(hf http.HandlerFunc) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			if err := jwtMiddleware.CheckJWT(w, r); err != nil {
				msg := fmt.Sprintf("auth failure: %v", err)
				jwtMiddleware.Options.ErrorHandler(w, r, msg)
				return
			}
			hf(w, r)
		}
	}
	// Note: routes are evaluated in the order they're defined.
	p := pat.New()
	p.Get("/login", loginLink)
	p.Get("/auth/{provider}/callback", oauthCallbackHandler)
	p.Get("/auth/{provider}", loginHandler)
	p.Get("/logout/{provider}", logoutHandler)
	p.Post("/", protect(websocketsProxy(wsproxy)))
	p.Get("/", protect(homeHandler))

	addr := "localhost:2016"
	httpsSrv := &http.Server{
		Addr:    addr,
		Handler: p,
		// Some security settings
		ReadHeaderTimeout: 5 * time.Second,
		IdleTimeout:       120 * time.Second,
		TLSConfig: &tls.Config{
			PreferServerCipherSuites: true,
			CurvePreferences: []tls.CurveID{
				tls.CurveP256,
				tls.X25519,
			},
		},
	}

	logger.Info("Serving on https://" + addr)
	logger.Fatal("handler exit: %v", httpsSrv.ListenAndServeTLS("./cert.pem", "./key.pem"))

}

var indexTemplate = `
<p><a href="/auth/auth0">Log in with auth0</a></p>
`

var userTemplate = `
<p><a href="/logout/{{.Provider}}">logout</a></p>
<p>Name: {{.Name}} [{{.LastName}}, {{.FirstName}}]</p>
<p>Email: {{.Email}}</p>
<p>NickName: {{.NickName}}</p>
<p>Location: {{.Location}}</p>
<p>AvatarURL: {{.AvatarURL}} <img src="{{.AvatarURL}}"></p>
<p>Description: {{.Description}}</p>
<p>UserID: {{.UserID}}</p>
<p>AccessToken: {{.AccessToken}}</p>
<p>ExpiresAt: {{.ExpiresAt}}</p>
<p>RefreshToken: {{.RefreshToken}}</p>
`

type ProviderIndex struct {
	Providers    []string
	ProvidersMap map[string]string
}

func extractor(r *http.Request) (string, error) {
	if r == nil {
		return "", errors.New("no http request provided")
	}

	c, err := r.Cookie("auth0_gothic_session")
	if err != nil {
		return "", fmt.Errorf("cookie read: %v", err)
	}
	return c.Value, nil
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
	if gothUser, err := gothic.CompleteUserAuth(w, r); err == nil {
		// TODO: redirect to app instead of serving example page
		t, _ := template.New("foo").Parse(userTemplate)
		t.Execute(w, gothUser)
	} else {
		gothic.BeginAuthHandler(w, r)
	}
}

func loginLink(w http.ResponseWriter, r *http.Request) {
	t, _ := template.New("foo").Parse(indexTemplate)
	t.Execute(w, nil)
}

func logoutHandler(w http.ResponseWriter, r *http.Request) {
	gothic.Logout(w, r)
	w.Header().Set("Location", "/")
	w.WriteHeader(http.StatusTemporaryRedirect)
}

func oauthCallbackHandler(w http.ResponseWriter, r *http.Request) {
	user, err := gothic.CompleteUserAuth(w, r)
	if err != nil {
		fmt.Fprintln(w, err)
		return
	}
	_ = user // TODO: what to do with user, if anything?
	w.Header().Set("Location", "/")
	w.WriteHeader(http.StatusTemporaryRedirect)
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	http.FileServer(bundle.Assets).ServeHTTP(w, r)
}

func websocketsProxy(wsproxy http.Handler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") ||
			websocket.IsWebSocketUpgrade(r) {
			wsproxy.ServeHTTP(w, r)
		}
	}
}
