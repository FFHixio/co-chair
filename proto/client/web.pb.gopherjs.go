// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: proto/web.proto

/*
	Package client is a generated protocol buffer package.

	Web exposes a backend server over gRPC.

	It is generated from these files:
		proto/web.proto

	It has these top-level messages:
		Backend
		ProxyState
		OpResult
		StateRequest
*/
package client

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type Backend struct {
	Domain string
	Ips    []string
}

// GetDomain gets the Domain of the Backend.
func (m *Backend) GetDomain() (x string) {
	if m == nil {
		return x
	}
	return m.Domain
}

// GetIps gets the Ips of the Backend.
func (m *Backend) GetIps() (x []string) {
	if m == nil {
		return x
	}
	return m.Ips
}

// MarshalToWriter marshals Backend to the provided writer.
func (m *Backend) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Domain) > 0 {
		writer.WriteString(1, m.Domain)
	}

	for _, val := range m.Ips {
		writer.WriteString(2, val)
	}

	return
}

// Marshal marshals Backend to a slice of bytes.
func (m *Backend) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Backend from the provided reader.
func (m *Backend) UnmarshalFromReader(reader jspb.Reader) *Backend {
	for reader.Next() {
		if m == nil {
			m = &Backend{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Domain = reader.ReadString()
		case 2:
			m.Ips = append(m.Ips, reader.ReadString())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Backend from a slice of bytes.
func (m *Backend) Unmarshal(rawBytes []byte) (*Backend, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ProxyState struct {
	Backends []*Backend
	// a status message, or an error message.
	Status string
	// an error code
	Code int32
}

// GetBackends gets the Backends of the ProxyState.
func (m *ProxyState) GetBackends() (x []*Backend) {
	if m == nil {
		return x
	}
	return m.Backends
}

// GetStatus gets the Status of the ProxyState.
func (m *ProxyState) GetStatus() (x string) {
	if m == nil {
		return x
	}
	return m.Status
}

// GetCode gets the Code of the ProxyState.
func (m *ProxyState) GetCode() (x int32) {
	if m == nil {
		return x
	}
	return m.Code
}

// MarshalToWriter marshals ProxyState to the provided writer.
func (m *ProxyState) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, msg := range m.Backends {
		writer.WriteMessage(1, func() {
			msg.MarshalToWriter(writer)
		})
	}

	if len(m.Status) > 0 {
		writer.WriteString(2, m.Status)
	}

	if m.Code != 0 {
		writer.WriteInt32(3, m.Code)
	}

	return
}

// Marshal marshals ProxyState to a slice of bytes.
func (m *ProxyState) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ProxyState from the provided reader.
func (m *ProxyState) UnmarshalFromReader(reader jspb.Reader) *ProxyState {
	for reader.Next() {
		if m == nil {
			m = &ProxyState{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Backends = append(m.Backends, new(Backend).UnmarshalFromReader(reader))
			})
		case 2:
			m.Status = reader.ReadString()
		case 3:
			m.Code = reader.ReadInt32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ProxyState from a slice of bytes.
func (m *ProxyState) Unmarshal(rawBytes []byte) (*ProxyState, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type OpResult struct {
	Code   int32
	Status string
}

// GetCode gets the Code of the OpResult.
func (m *OpResult) GetCode() (x int32) {
	if m == nil {
		return x
	}
	return m.Code
}

// GetStatus gets the Status of the OpResult.
func (m *OpResult) GetStatus() (x string) {
	if m == nil {
		return x
	}
	return m.Status
}

// MarshalToWriter marshals OpResult to the provided writer.
func (m *OpResult) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Code != 0 {
		writer.WriteInt32(1, m.Code)
	}

	if len(m.Status) > 0 {
		writer.WriteString(2, m.Status)
	}

	return
}

// Marshal marshals OpResult to a slice of bytes.
func (m *OpResult) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a OpResult from the provided reader.
func (m *OpResult) UnmarshalFromReader(reader jspb.Reader) *OpResult {
	for reader.Next() {
		if m == nil {
			m = &OpResult{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Code = reader.ReadInt32()
		case 2:
			m.Status = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a OpResult from a slice of bytes.
func (m *OpResult) Unmarshal(rawBytes []byte) (*OpResult, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type StateRequest struct {
	// if domain is empty string, return "all" states, otherwise
	// match domain DNS-style, e.g. google.com matches docs.google.com
	Domain string
}

// GetDomain gets the Domain of the StateRequest.
func (m *StateRequest) GetDomain() (x string) {
	if m == nil {
		return x
	}
	return m.Domain
}

// MarshalToWriter marshals StateRequest to the provided writer.
func (m *StateRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Domain) > 0 {
		writer.WriteString(1, m.Domain)
	}

	return
}

// Marshal marshals StateRequest to a slice of bytes.
func (m *StateRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a StateRequest from the provided reader.
func (m *StateRequest) UnmarshalFromReader(reader jspb.Reader) *StateRequest {
	for reader.Next() {
		if m == nil {
			m = &StateRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Domain = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a StateRequest from a slice of bytes.
func (m *StateRequest) Unmarshal(rawBytes []byte) (*StateRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion2

// Client API for Proxy service

type ProxyClient interface {
	State(ctx context.Context, in *StateRequest, opts ...grpcweb.CallOption) (*ProxyState, error)
	Put(ctx context.Context, in *Backend, opts ...grpcweb.CallOption) (*OpResult, error)
	Remove(ctx context.Context, in *Backend, opts ...grpcweb.CallOption) (*OpResult, error)
}

type proxyClient struct {
	client *grpcweb.Client
}

// NewProxyClient creates a new gRPC-Web client.
func NewProxyClient(hostname string, opts ...grpcweb.DialOption) ProxyClient {
	return &proxyClient{
		client: grpcweb.NewClient(hostname, "web.Proxy", opts...),
	}
}

func (c *proxyClient) State(ctx context.Context, in *StateRequest, opts ...grpcweb.CallOption) (*ProxyState, error) {
	resp, err := c.client.RPCCall(ctx, "State", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(ProxyState).Unmarshal(resp)
}

func (c *proxyClient) Put(ctx context.Context, in *Backend, opts ...grpcweb.CallOption) (*OpResult, error) {
	resp, err := c.client.RPCCall(ctx, "Put", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(OpResult).Unmarshal(resp)
}

func (c *proxyClient) Remove(ctx context.Context, in *Backend, opts ...grpcweb.CallOption) (*OpResult, error) {
	resp, err := c.client.RPCCall(ctx, "Remove", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(OpResult).Unmarshal(resp)
}
